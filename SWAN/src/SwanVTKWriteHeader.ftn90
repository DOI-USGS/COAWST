subroutine SwanVTKWriteHeader ( uvtk, pstype, nvar, ivtyp, mxkf, mxkl, mykf, mykl )
!
!   --|-----------------------------------------------------------|--
!     | Delft University of Technology                            |
!     | Faculty of Civil Engineering and Geosciences              |
!     | Environmental Fluid Mechanics Section                     |
!     | P.O. Box 5048, 2600 GA  Delft, The Netherlands            |
!     |                                                           |
!     | Programmer: Marcel Zijlema                                |
!   --|-----------------------------------------------------------|--
!
!
!     SWAN (Simulating WAves Nearshore); a third generation wave model
!     Copyright (C) 1993-2023  Delft University of Technology
!
!     This program is free software: you can redistribute it and/or modify
!     it under the terms of the GNU General Public License as published by
!     the Free Software Foundation, either version 3 of the License, or
!     (at your option) any later version.
!
!     This program is distributed in the hope that it will be useful,
!     but WITHOUT ANY WARRANTY; without even the implied warranty of
!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!     GNU General Public License for more details.
!
!     You should have received a copy of the GNU General Public License
!     along with this program. If not, see <http://www.gnu.org/licenses/>.
!
!
!   Authors
!
!   41.95: Marcel Zijlema
!
!   Updates
!
!   41.95, July 2022: New subroutine
!
!   Purpose
!
!   Writes header to a VTK file
!
!   Method
!
!   See https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf
!
!   Modules used
!
    use ocpcomm2
    use ocpcomm4
    use swcomm1
    use outp_data
    use SwanGriddata
!
    implicit none
!
!   Argument variables
!
    integer, intent(in)                  :: mxkf   ! first index w.r.t. global output grid in x-direction
    integer, intent(in)                  :: mxkl   ! last index w.r.t. global output grid in x-direction
    integer, intent(in)                  :: mykf   ! first index w.r.t. global output grid in y-direction
    integer, intent(in)                  :: mykl   ! last index w.r.t. global output grid in y-direction
    integer, intent(in)                  :: nvar   ! number of output variables
    integer, intent(in)                  :: uvtk   ! unit number of VTK file
    !
    integer, dimension(nvar), intent(in) :: ivtyp  ! types of output variable
    !
    character(1), intent(in)             :: pstype ! type of output point set
!
!   Parameter variables
!
    integer     , parameter :: datasize = 4        ! number of bytes of integers and reals
    integer     , parameter :: ndim = 3            ! space dimension
                                                   ! (set to 3 as required by Paraview)
    integer     , parameter :: nov = 3             ! number of vertices in cell (triangles only)
    character(1), parameter :: lf = char(10)       ! line feed character
!
!   Local variables
!
    integer, save           :: ient = 0            ! number of entries in this subroutine
    integer                 :: if                  ! first character in string
    integer                 :: if2                 ! first character in string2
    integer                 :: il                  ! last character in string
    integer                 :: il2                 ! last character in string2
    integer                 :: ios                 ! I/O status
    integer*4               :: ioff                ! current file offset
    integer                 :: ivtype              ! type of output quantity
    integer                 :: jvar                ! loop counter over output variables
    integer                 :: mxk                 ! number of nodes in x-direction
    integer                 :: myk                 ! number of nodes in y-direction
    !
    character(200)          :: extstr              ! string to pass grid extent
    character(12)           :: intstr              ! string to pass number or file offset
    character(12)           :: intstr2             ! another string
    character(80)           :: msgstr              ! string to pass message
    character(6)            :: namvar              ! name of output variable
!
!   Structure
!
!   Description of the pseudo code
!
!   Source text
!
    if (ltrace) call strace (ient,'SwanVTKWriteHeader')
    !
    ios = 0
    !
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(xmllin1//lf)
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(xmllin2//lf)
    vtkline = '  This file was generated by SWAN version '//trim(VERTXT)//'; project: '//trim(PROJID)//'; run number: '//trim(PROJNR)//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(xmllin3//lf)
    !
    ! start of the header
    !
    if ( pstype == 'F' .or. pstype == 'H' ) then
       !
       vtkline = '<VTKFile type="StructuredGrid" version="0.1" byte_order="LittleEndian">'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       write(intstr(1:12),'(i12)') mxkf-1
       call TXPBLA(intstr,if,il)
       write(intstr2(1:12),'(i12)') mxkl-1
       call TXPBLA(intstr2,if2,il2)
       extstr = intstr(if:il)//" "//intstr2(if2:il2)
       write(intstr(1:12),'(i12)') mykf-1
       call TXPBLA(intstr,if,il)
       write(intstr2(1:12),'(i12)') mykl-1
       call TXPBLA(intstr2,if2,il2)
       extstr = extstr(1:len_trim(extstr))//" "//intstr(if:il)//" "//intstr2(if2:il2)//" 0 0"
       !
       vtkline = '  <StructuredGrid WholeExtent="'//extstr(1:len_trim(extstr))//'">'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       vtkline = '    <Piece Extent="'//extstr(1:len_trim(extstr))//'">'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
    elseif ( pstype == 'U' ) then
       !
       vtkline = '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       vtkline = '  <UnstructuredGrid>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       write(intstr(1:12),'(i12)') nverts
       call TXPBLA(intstr,if,il)
       write(intstr2(1:12),'(i12)') ncells
       call TXPBLA(intstr2,if2,il2)
       !
       vtkline = '    <Piece NumberOfPoints="'//intstr(if:il)//'" NumberOfCells="'//intstr2(if2:il2)//'">'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
    endif
    !
    ! below are the output variables associated with nodes
    !
    vtkline = '      <PointData> '//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ioff = 0                                 ! this is the first character after the underscore in the appended data (see below)
    !
    mxk = mxkl - mxkf + 1
    myk = mykl - mykf + 1
    !
    ! for each output variable determine the file offset and write to file
    !
    do jvar = 1, nvar
       !
       ivtype = ivtyp(jvar)
       !
       if ( ovsvty(ivtype) < 3 ) then        ! scalars
          !
          namvar = ovsnam(ivtype)
          !
          write(intstr(1:12),'(i12)') ioff
          call TXPBLA(intstr,if,il)
          !
          vtkline = '        <DataArray type="Float32" Name="'//namvar(1:len_trim(namvar))//'" format="appended" offset="'//intstr(if:il)//'"/>'//lf
          if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
          !
          ioff = ioff + datasize + mxk * myk * datasize
          !
       else                                  ! vectors (three components per node!)
          !
          namvar = ovsnam(ivtype)
          !
          write(intstr(1:12),'(i12)') ioff
          call TXPBLA(intstr,if,il)
          !
          vtkline = '        <DataArray type="Float32" Name="'//namvar(1:len_trim(namvar))//'" NumberOfComponents="3" format="appended" offset="'//intstr(if:il)//'"/>'//lf
          if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
          !
          ioff = ioff + datasize + ndim * mxk * myk * datasize
          !
       endif
       !
    enddo
    !
    vtkline = '      </PointData>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! no output variables associated with cells
    !
    vtkline = '      <CellData> </CellData>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! below are the coordinates of nodes
    ! note: Paraview expects three components per node, therefore z = 0
    !
    vtkline = '      <Points>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    write(intstr(1:12),'(i12)') ioff
    call TXPBLA(intstr,if,il)
    !
    vtkline = '        <DataArray type="Float32" Name="coordinates" NumberOfComponents="3" format="appended" offset="'//intstr(if:il)//'"/>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ioff = ioff + datasize + ndim * nverts * datasize
    !
    vtkline = '      </Points>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    if ( pstype == 'U' ) then
       !
       ! below are the connectivity, offset and cell type; all associated with the cells
       !
       vtkline = '      <Cells>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       write(intstr(1:12),'(i12)') ioff
       call TXPBLA(intstr,if,il)
       !
       vtkline = '        <DataArray type="Int32" Name="connectivity" format="appended" offset="'//intstr(if:il)//'"/>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       ioff = ioff + datasize + nov * ncells * datasize
       !
       write(intstr(1:12),'(i12)') ioff
       call TXPBLA(intstr,if,il)
       !
       vtkline = '        <DataArray type="Int32" Name="offsets" format="appended" offset="'//intstr(if:il)//'"/>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       ioff = ioff + datasize + ncells * datasize
       !
       write(intstr(1:12),'(i12)') ioff
       call TXPBLA(intstr,if,il)
       !
       vtkline = '        <DataArray type="UInt8" Name="types" format="appended" offset="'//intstr(if:il)//'"/>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
       vtkline = '      </Cells>'//lf
       if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
       !
    endif
    !
    vtkline = '    </Piece>'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! end of the header
    !
    if ( pstype == 'F' .or. pstype == 'H' ) then
       !
       vtkline = '  </StructuredGrid>'//lf
       !
    else
       !
       vtkline = '  </UnstructuredGrid>'//lf
       !
    endif
    !
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! below is the start of appended data
    !
    vtkline = '  <AppendedData encoding="raw">'//lf
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! the appended data section begins with the underscore
    !
    vtkline = '_'
    if ( ios == 0 ) write(uvtk,iostat=ios) trim(vtkline)
    !
    ! if necessary, give message that error occurred while writing file
    !
    if ( ios /= 0 ) then
       write (msgstr, '(a,i5)') 'Error while writing VTK file - iostat number =',ios
       call msgerr( 2, trim(msgstr) )
    endif
    !
end subroutine SwanVTKWriteHeader
