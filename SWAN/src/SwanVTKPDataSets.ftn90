subroutine SwanVTKPDataSets ( upvt, pstype, nvar, ivtyp, mxk, myk, vtkfile, upvd, psname, iarr )
!
!   --|-----------------------------------------------------------|--
!     | Delft University of Technology                            |
!     | Faculty of Civil Engineering and Geosciences              |
!     | Environmental Fluid Mechanics Section                     |
!     | P.O. Box 5048, 2600 GA  Delft, The Netherlands            |
!     |                                                           |
!     | Programmer: Marcel Zijlema                                |
!   --|-----------------------------------------------------------|--
!
!
!     SWAN (Simulating WAves Nearshore); a third generation wave model
!     Copyright (C) 1993-2023  Delft University of Technology
!
!     This program is free software: you can redistribute it and/or modify
!     it under the terms of the GNU General Public License as published by
!     the Free Software Foundation, either version 3 of the License, or
!     (at your option) any later version.
!
!     This program is distributed in the hope that it will be useful,
!     but WITHOUT ANY WARRANTY; without even the implied warranty of
!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!     GNU General Public License for more details.
!
!     You should have received a copy of the GNU General Public License
!     along with this program. If not, see <http://www.gnu.org/licenses/>.
!
!
!   Authors
!
!   41.95: Marcel Zijlema
!
!   Updates
!
!   41.95, July 2022: New subroutine
!
!   Purpose
!
!   Writes parallel VTK file type
!
!   Method
!
!   See https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf
!
!   Modules used
!
    use ocpcomm2
    use ocpcomm4
    use swcomm1
    use swcomm3
    use m_parall
    use outp_data
!
    implicit none
!
!   Argument variables
!
    integer, intent(in)                         :: mxk     ! number of nodes in x-direction
    integer, intent(in)                         :: myk     ! number of nodes in y-direction
    integer, intent(in)                         :: nvar    ! number of output variables
    integer, intent(in)                         :: upvd    ! unit number of PVD file
    integer, intent(in)                         :: upvt    ! unit number of parallel VTK file
    !
    integer, dimension(4,0:NPROC-1), intent(in) :: iarr    ! array with collecting grid indices
    integer, dimension(nvar), intent(in)        :: ivtyp   ! types of output variable
    !
    character(len=8), intent(in)                :: psname  ! name of output frame
    character(len=1), intent(in)                :: pstype  ! type of output point set
    character(len=lenfnm), intent(in)           :: vtkfile ! a VTK file
!
!   Local variables
!
    integer, save     :: ient = 0          ! number of entries in this subroutine
    integer           :: if                ! first character in string
    integer           :: if2               ! first character in string2
    integer           :: il                ! last character in string
    integer           :: il2               ! last character in string2
    integer           :: ilpos             ! actual length of filename
    integer           :: iproc             ! loop counter over processors
    integer           :: ivtype            ! type of output quantity
    integer           :: jvar              ! loop counter over output variables
    !
    logical, save     :: nowarn  = .false. ! give no warning again (only nonstationary mode)
    logical           :: lc                ! indicates low characters in string
    !
    character(200)    :: extstr            ! string to pass grid extent
    character(12)     :: intstr            ! string to pass number or file offset
    character(12)     :: intstr2           ! another string
    character(120)    :: msgstr            ! string to pass message
    character(6)      :: namvar            ! name of output variable
    character(lenfnm) :: pfile             ! file linked to processor
    character(4)      :: pnum              ! string to pass processor counter
!
!   Structure
!
!   Description of the pseudo code
!
!   Source text
!
    if (ltrace) call strace (ient,'SwanVTKPDataSets')
    !
    write(upvt,'(a)') trim(xmllin1)
    write(upvt,'(a)') trim(xmllin2)
    vtkline = '  This file was generated by SWAN version '//trim(VERTXT)//'; project: '//trim(PROJID)//'; run number: '//trim(PROJNR)
    write(upvt,'(a)') trim(vtkline)
    write(upvt,'(a)') trim(xmllin3)
    !
    ! start of the header
    !
    if ( pstype == 'F' .or. pstype == 'H' ) then
       !
       vtkline = '<VTKFile type="PStructuredGrid" version="0.1" byte_order="LittleEndian">'
       write(upvt,'(a)') trim(vtkline)
       !
       write(intstr(1:12),'(i12)') mxk-1
       call TXPBLA(intstr,if,il)
       write(intstr2(1:12),'(i12)') myk-1
       call TXPBLA(intstr2,if2,il2)
       extstr = "0 "//intstr(if:il)//" 0 "//intstr2(if2:il2)//" 0 0"
       !
       vtkline = '  <PStructuredGrid WholeExtent="'//extstr(1:len_trim(extstr))//'" GhostLevel="0">'
       write(upvt,'(a)') trim(vtkline)
       !
    elseif ( pstype == 'U' ) then
       !
       vtkline = '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
       write(upvt,'(a)') trim(vtkline)
       !
       vtkline = '  <PUnstructuredGrid GhostLevel="0">'
       write(upvt,'(a)') trim(vtkline)
       !
    endif
    !
    ! below are the output variables associated with nodes
    !
    vtkline = '    <PPointData> '
    write(upvt,'(a)') trim(vtkline)
    !
    ! for each output variable write its short name to file
    !
    do jvar = 1, nvar
       !
       ivtype = ivtyp(jvar)
       !
       if ( ovsvty(ivtype) < 3 ) then        ! scalars
          !
          namvar = ovsnam(ivtype)
          !
          vtkline = '      <PDataArray type="Float32" Name="'//namvar(1:len_trim(namvar))//'"/>'
          write(upvt,'(a)') trim(vtkline)
          !
       else                                  ! vectors (three components per node!)
          !
          namvar = ovsnam(ivtype)
          !
          vtkline = '      <PDataArray type="Float32" Name="'//namvar(1:len_trim(namvar))//'" NumberOfComponents="3"/>'
          write(upvt,'(a)') trim(vtkline)
          !
       endif
       !
    enddo
    !
    vtkline = '    </PPointData>'
    write(upvt,'(a)') trim(vtkline)
    !
    ! no output variables associated with cells
    !
    vtkline = '    <PCellData> </PCellData>'
    write(upvt,'(a)') trim(vtkline)
    !
    ! below are the coordinates of nodes
    !
    vtkline = '    <PPoints>'
    write(upvt,'(a)') trim(vtkline)
    !
    vtkline = '      <DataArray type="Float32" NumberOfComponents="3"/>'
    write(upvt,'(a)') trim(vtkline)
    !
    vtkline = '    </PPoints>'
    write(upvt,'(a)') trim(vtkline)
    !
    ! write references of pieces of data
    !
    lc = .false.
    ilpos = index( vtkfile, '.VT' )
    if ( ilpos == 0 ) lc = .true.
    !
    ilpos = index( vtkfile, '_001' )
    pfile = vtkfile
    !
    if ( pstype == 'F' .or. pstype == 'H' ) then
       !
       ! first, check consistency of output grid partition ...
       !
       if ( maxval(iarr(3,:)) == 1 .and. (minval(iarr(4,:)) == myk .or. minval(iarr(4,:)) == 0) ) then
          !
          do iproc = 1, NPROC-1
             !
             if ( iarr(1,iproc-1) <= iarr(2,iproc-1) .and. iarr(1,iproc) <= iarr(2,iproc) ) then
                if ( iarr(1,iproc) /= iarr(2,iproc-1) ) then
                   write (msgstr, '(a,i3,a,i3)') 'inconsistency found in SwanVTKPDataSets: the end of subdomain ',iproc,' does not match the start of subdomain ',iproc+1
                   call msgerr ( 2, trim(msgstr) )
                   write (msgstr, '(a,a8)') 'name of output grid is ',psname
                   call msgerr ( 0, trim(msgstr) )
                endif
             endif
             !
          enddo
          !
       elseif ( maxval(iarr(1,:)) == 1 .and. (minval(iarr(2,:)) == mxk .or. minval(iarr(2,:)) == 0) ) then
          !
          do iproc = 1, NPROC-1
             !
             if ( iarr(3,iproc-1) <= iarr(4,iproc-1) .and. iarr(3,iproc) <= iarr(4,iproc) ) then
                if ( iarr(3,iproc) /= iarr(4,iproc-1) ) then
                   write (msgstr, '(a,i3,a,i3)') 'inconsistency found in SwanVTKPDataSets: the end of subdomain ',iproc,' does not match the start of subdomain ',iproc+1
                   call msgerr ( 2, trim(msgstr) )
                   write (msgstr, '(a,a8)') 'name of output grid is ',psname
                   call msgerr ( 0, trim(msgstr) )
                endif
             endif
             !
          enddo
          !
       else
          !
          write (msgstr, '(a,a8)') 'something went wrong with partition of output grid ',psname
          call msgerr ( 3, trim(msgstr) )
          !
       endif
       !
       ! ... next, write piece extents
       !
       do iproc = 1, NPROC
          !
          write(intstr(1:12),'(i12)') iarr(1,iproc-1)-1
          call TXPBLA(intstr,if,il)
          write(intstr2(1:12),'(i12)') iarr(2,iproc-1)-1
          call TXPBLA(intstr2,if2,il2)
          extstr = intstr(if:il)//" "//intstr2(if2:il2)
          write(intstr(1:12),'(i12)') iarr(3,iproc-1)-1
          call TXPBLA(intstr,if,il)
          write(intstr2(1:12),'(i12)') iarr(4,iproc-1)-1
          call TXPBLA(intstr2,if2,il2)
          extstr = extstr(1:len_trim(extstr))//" "//intstr(if:il)//" "//intstr2(if2:il2)//" 0 0"
          !
          if ( (iarr(1,iproc-1) > iarr(2,iproc-1) .or. iarr(3,iproc-1) > iarr(4,iproc-1)) .and. .not.nowarn ) then
             write (msgstr, '(a,i3,a,a8)') 'empty subdomain of output grid is detected - node number is ',iproc,' and output frame is ',psname
             call msgerr ( 1, trim(msgstr) )
             if ( NSTATC /= 0 ) nowarn = .true.
          endif
          !
          if ( upvd > 0 ) then
             if ( lc ) then
                write(pnum(1:4),10) 'p',iproc
             else
                write(pnum(1:4),10) 'P',iproc
             endif
          else
             write(pnum(1:4),12) '.   '
          endif
          !
          write(pfile(ilpos+1:ilpos+3),15) iproc
          !
          vtkline = '    <Piece Extent="'//extstr(1:len_trim(extstr))//'" Source="'//pnum(1:len_trim(pnum))//DIRCH2//pfile(1:len_trim(pfile))//'"/>'
          write(upvt,'(a)') trim(vtkline)
          !
       enddo
       !
       vtkline = '  </PStructuredGrid>'
       write(upvt,'(a)') trim(vtkline)
       !
    else
       !
       do iproc = 1, NPROC
          !
          if ( upvd > 0 ) then
             if ( lc ) then
                write(pnum(1:4),10) 'p',iproc
             else
                write(pnum(1:4),10) 'P',iproc
             endif
          else
             write(pnum(1:4),12) '.   '
          endif
          !
          write(pfile(ilpos+1:ilpos+3),15) iproc
          !
          vtkline = '    <Piece Source="'//pnum(1:len_trim(pnum))//DIRCH2//pfile(1:len_trim(pfile))//'"/>'
          write(upvt,'(a)') trim(vtkline)
          !
       enddo
       !
       vtkline = '  </PUnstructuredGrid>'
       write(upvt,'(a)') trim(vtkline)
       !
    endif
 10 format(a1,i3.3)
 12 format(a4)
 15 format(i3.3)
    !
    ! end of the file
    !
    vtkline = '</VTKFile>'
    write(upvt,'(a)') trim(vtkline)
    !
end subroutine SwanVTKPDataSets
